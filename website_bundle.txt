===============================================================================
 ПРОЕКТНЫЙ БАНДЛ
 Создан: 2025-04-27 21:22:36
 Исходная директория: A:\Progects\letopisets-website
===============================================================================

--- START OF FILE: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


--- END OF FILE: .gitignore ---

-------------------------------------------------------------------------------

--- START OF FILE: package.json ---

{
  "name": "letopisets-website",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0",
    "@radix-ui/react-separator": "^1.1.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@tanstack/react-query": "^5.74.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "copy-to-clipboard": "^3.3.3",
    "framer-motion": "^12.9.2",
    "lucide-react": "^0.503.0",
    "next": "15.3.1",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.2.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "postcss": "^8.5.3",
    "prisma": "^6.6.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "ts-node": "^10.9.2",
    "typescript": "^5"
  },
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  }
}


--- END OF FILE: package.json ---

-------------------------------------------------------------------------------

--- START OF FILE: postcss.config.mjs ---

/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
export default config;

--- END OF FILE: postcss.config.mjs ---

-------------------------------------------------------------------------------

--- START OF FILE: README.md ---

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


--- END OF FILE: README.md ---

-------------------------------------------------------------------------------

--- START OF FILE: tailwind.config.ts ---

// tailwind.config.ts
import type { Config } from "tailwindcss"
import tailwindcssAnimate from "tailwindcss-animate" // <--- Импорт вместо require
import tailwindcssTypography from "@tailwindcss/typography" 

const config = {
  darkMode: "class", // Используем класс 'dark' для темной темы
  content: [
    './pages/**/*.{ts,tsx}', // На всякий случай, если есть старые страницы
    './components/**/*.{ts,tsx}', // Папка компонентов shadcn/ui
    './app/**/*.{ts,tsx}', // Папка App Router
    './src/**/*.{ts,tsx}', // Включаем всю папку src
	],
  prefix: "", // Убираем префикс tw- (если не нужен)
  theme: {
    container: {
      center: true,
      padding: "1rem", // Уменьшаем паддинг по умолчанию
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
       // Здесь можно расширять стандартную тему Tailwind,
       // но основные цвета и радиусы у вас задаются через CSS переменные
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
       backgroundImage: { // Пример добавления своего значения (если нужно)
         'gradient-dark': 'linear-gradient(180deg, hsl(var(--background)) 0%, hsl(var(--muted)) 100%)',
       }
    },
  },
  plugins: [
    tailwindcssAnimate,      
    tailwindcssTypography     
  ],
} satisfies Config

export default config

--- END OF FILE: tailwind.config.ts ---

-------------------------------------------------------------------------------

--- START OF FILE: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "~/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


--- END OF FILE: tsconfig.json ---

-------------------------------------------------------------------------------

--- START OF FILE: prisma/schema.prisma ---



generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Content {
  id        String   @id @default(cuid())
  key       String   @unique
  valueRu   String
  valueEn   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Feature {
  id            String   @id @default(cuid())
  titleRu       String
  titleEn       String
  descriptionRu String
  descriptionEn String
  icon          String
  order         Int      @unique 
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Example {
  id            String   @id @default(cuid())
  personalityRu String
  personalityEn String
  contentRu     String
  contentEn     String
  order         Int      @unique 
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}


--- END OF FILE: prisma/schema.prisma ---

-------------------------------------------------------------------------------

--- START OF FILE: prisma/seed.ts ---

// prisma/seed.ts

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// ============================================================================
// --- ВАШИ ДАННЫЕ ДЛЯ НАПОЛНЕНИЯ ---
// ЗАМЕНИТЕ ЭТИ ПЛЕЙСХОЛДЕРЫ НА ВАШ РЕАЛЬНЫЙ КОНТЕНТ!
// ============================================================================

const contentData = [
  // Hero Section & CTA
  { key: 'hero_title', valueRu: 'Летописец Чата: Ваш ИИ-помощник для Telegram', valueEn: 'Chat Chronicler: Your AI Assistant for Telegram' },
  { key: 'hero_subtitle', valueRu: 'Превращает хаос чата в увлекательные истории и дайджесты. Помогает не упустить важное и экономит ваше время.', valueEn: 'Turns chat chaos into engaging stories and digests. Helps you catch up and saves your time.' },
  { key: 'cta_button', valueRu: 'Добавить в Telegram', valueEn: 'Add to Telegram' },
  { key: 'telegram_bot_username', valueRu: 'LetopisetsChatBot', valueEn: 'LetopisetsChatBot' },
  { key: 'bot_image', valueRu: '/images/bot-avatar.png', valueEn: '/images/bot-avatar.png' },

  // Problem/Solution
  { key: 'problem_title', valueRu: 'Проблема: Информационная перегрузка', valueEn: 'Problem: Information Overload' },
  { key: 'problem_text', valueRu: 'Сложно следить за активными чатами? Пропускаете важные обсуждения и решения? Устали пролистывать сотни сообщений?', valueEn: 'Hard to keep up with active chats? Missing important discussions and decisions? Tired of scrolling through hundreds of messages?' },
  { key: 'solution_title', valueRu: 'Решение: Летописец Чата', valueEn: 'Solution: Chat Chronicler' },
  { key: 'solution_text', valueRu: 'Наш ИИ-бот анализирует историю чата и создает понятные сводки: краткие дайджесты или увлекательные истории дня с разными "личностями".', valueEn: 'Our AI bot analyzes chat history and creates clear summaries: concise digests or engaging stories of the day with different "personalities".' },

  // Titles
  { key: 'features_title', valueRu: 'Возможности', valueEn: 'Features' },
  { key: 'how_it_works_title', valueRu: 'Как это работает?', valueEn: 'How It Works?' },
  { key: 'examples_title', valueRu: 'Примеры работы (Личности ИИ)', valueEn: 'Examples (AI Personalities)' },
  { key: 'privacy_title', valueRu: 'Приватность и Безопасность', valueEn: 'Privacy & Security' },
  { key: 'privacy_policy_title', valueRu: 'Политика Конфиденциальности', valueEn: 'Privacy Policy' },
  { key: 'setup_title', valueRu: 'Установка и Настройка', valueEn: 'Setup & Configuration' },

  // How It Works Steps
  { key: 'step1_title', valueRu: 'Добавьте Бота', valueEn: 'Add the Bot' },
  { key: 'step1_text', valueRu: 'Нажмите кнопку "Добавить в Telegram" и выберите группу, в которую хотите установить Летописца.', valueEn: 'Click the "Add to Telegram" button and select the group where you want to install the Chronicler.' },
  { key: 'step2_title', valueRu: 'Дайте Права', valueEn: 'Grant Permissions' },
  { key: 'step2_text', valueRu: 'Сделайте бота администратором группы. Ему нужны права на чтение сообщений для анализа и отправку сообщений для сводок.', valueEn: 'Make the bot an administrator of the group. It needs permissions to read messages for analysis and send messages for summaries.' },
  { key: 'step3_title', valueRu: 'Настройте', valueEn: 'Configure' },
  { key: 'step3_text', valueRu: 'Используйте команду /story_settings (доступна админам), чтобы выбрать язык, формат сводки, личность ИИ, время генерации и другие параметры.', valueEn: 'Use the /story_settings command (admins only) to choose the language, summary format, AI personality, generation time, and other options.' },
  { key: 'step4_title', valueRu: 'Готово!', valueEn: 'Enjoy!' },
  { key: 'step4_text', valueRu: 'Бот начнет собирать историю чата и будет присылать сводки согласно вашим настройкам. Используйте /help для списка команд.', valueEn: 'The bot will start collecting chat history and send summaries according to your settings. Use /help for a list of commands.' },

  // Setup Page Specific
   { key: 'setup_intro', valueRu: 'Следуйте этим простым шагам, чтобы Летописец начал работать в вашем чате.', valueEn: 'Follow these simple steps to get the Chronicler working in your chat.' },
   { key: 'setup_permissions_title', valueRu: 'Необходимые права администратора:', valueEn: 'Required Admin Permissions:' },
   { key: 'setup_permissions_text', valueRu: 'Боту необходимы права для чтения сообщений (чтобы анализировать чат) и отправки сообщений (чтобы публиковать сводки). Он не будет удалять сообщения (кроме как по команде /purge_history), банить пользователей или менять настройки чата.', valueEn: 'The bot needs permissions to read messages (to analyze the chat) and send messages (to publish summaries). It will not delete messages (except via /purge_history), ban users, or change chat settings.' },

  // Privacy Section on Home
  { key: 'privacy_text', valueRu: 'Мы серьезно относимся к вашей конфиденциальности. Данные чатов используются только для генерации сводок и не передаются третьим лицам, кроме как для обработки ИИ через наш защищенный прокси. Узнайте больше в нашей Политике Конфиденциальности.', valueEn: 'We take your privacy seriously. Chat data is used solely for generating summaries and is not shared with third parties, except for AI processing via our secure proxy. Learn more in our Privacy Policy.' },

  // Footer
  { key: 'footer_copyright', valueRu: `© ${new Date().getFullYear()} Летописец Чата. Все права защищены.`, valueEn: `© ${new Date().getFullYear()} Chat Chronicler. All rights reserved.` },

  // Privacy Policy Page (Full Text in Markdown)
  { key: 'privacy_policy_text', valueRu: `
    # Политика Конфиденциальности для Бота "Летописец Чата"
    
    **Дата вступления в силу:** [Дата вступления в силу, например: 28 Апреля 2025 года]
    
    ## 1. Введение
    
    Добро пожаловать! Настоящая Политика Конфиденциальности описывает, как [Ваш/Ваше Имя или Название Проекта] ("мы", "нас" или "наш") собирает, использует и раскрывает информацию пользователей ("вы") при использовании нашего Telegram-бота "Летописец Чата" ("Бот") и связанного с ним веб-сайта ([Адрес вашего сайта]) ("Сайт").
    
    Используя Бота или Сайт, вы соглашаетесь с условиями настоящей Политики Конфиденциальности. Если вы не согласны с этими условиями, пожалуйста, не используйте Бота или Сайт. Администраторы Telegram-групп, добавляющие Бота в свои чаты, несут ответственность за информирование участников своих чатов о работе Бота и данной Политике.
    
    ## 2. Какую информацию мы собираем
    
    Бот собирает следующую информацию для выполнения своих функций:
    
    *   **Информация из сообщений в группах:**
        *   Текстовое содержание сообщений.
        *   Telegram User ID и Username (если доступен) пользователя, отправившего сообщение.
        *   Chat ID группы, в которой установлен Бот.
        *   Время отправки сообщения (Timestamp).
        *   Тип сообщения (текст, фото, стикер, видео и т.д.).
        *   File ID и File Unique ID для медиафайлов (фото, видео, документы и т.д.).
        *   Подписи (captions) к медиафайлам.
    *   **Настройки Чата:**
        *   Язык интерфейса Бота (\`lang\`).
        *   Статус активности Бота в чате (\`enabled\`).
        *   Пользовательское время генерации сводок (\`custom_schedule_time\`).
        *   Часовой пояс чата (\`timezone\`).
        *   Выбранный жанр для "Историй" (\`story_genre\`).
        *   Выбранный формат сводки ("История" или "Дайджест") (\`output_format\`).
        *   Выбранная личность Летописца (\`story_personality\`).
        *   Настроенный срок хранения сообщений (\`retention_days\`).
        *   Настройки функции "Вмешательства" (\`allow_interventions\`, \`last_intervention_ts\`, \`intervention_cooldown_minutes\`, \`intervention_min_msgs\`, \`intervention_timespan_minutes\`).
    *   **Данные Обратной Связи:**
        *   Telegram User ID пользователя, оставившего отзыв.
        *   Chat ID и Message ID сообщения, к которому относится отзыв.
        *   Оценка (👍 или 👎).
        *   Время оставления отзыва.
    *   **Информация, передаваемая для обработки ИИ:**
        *   Текстовое содержание сообщений и подписей к медиа.
        *   Информация из изображений (обрабатывается моделью Google Gemini). Данные передаются через наш прокси-сервис.
    
    ## 3. Как мы собираем информацию
    
    *   Информация из сообщений и данные пользователей собираются автоматически через Telegram Bot API, когда вы или другие участники отправляете сообщения в группе, где установлен Бот.
    *   Настройки чата собираются при использовании команды \`/story_settings\` и взаимодействии с меню настроек.
    *   Данные обратной связи собираются при нажатии на кнопки 👍/👎 под сгенерированными сводками.
    
    ## 4. Цели сбора и использования информации
    
    Мы используем собранную информацию для следующих целей:
    
    *   **Предоставление основной функциональности Бота:** Генерация ежедневных "Историй" или "Дайджестов", создание кратких выжимок по команде \`/summarize\`, расчет статистики чата по команде \`/chat_stats\`.
    *   **Обработка с помощью Искусственного Интеллекта:** Передача текстовых данных и данных изображений (через прокси-сервис) в Google Gemini API для анализа и генерации текстовых сводок и комментариев.
    *   **Персонализация:** Применение настроек чата (язык, время, личность, формат и т.д.), выбранных администратором.
    *   **Функция "Вмешательства":** Генерация и отправка коротких комментариев в чат (только если эта функция явно включена администратором и соблюдены настроенные условия).
    *   **Улучшение Бота:** Анализ данных обратной связи для повышения качества генерируемых сводок и работы Бота.
    *   **Поддержка и Диагностика:** Помощь в устранении неполадок и ошибок в работе Бота.
    *   **Обеспечение Соблюдения Политики:** Мониторинг использования для предотвращения злоупотреблений.
    
    ## 5. Хранение данных
    
    *   Собранные данные (сообщения, настройки, отзывы) хранятся в базе данных SQLite, расположенной на нашем сервере ([Укажите тип хостинга/локацию, например: на виртуальной машине Cloud.ru в России]).
    *   Срок хранения сообщений определяется настройкой "Срок хранения" (\`retention_days\`) в настройках чата. По умолчанию сообщения хранятся [Ваше значение DEFAULT_RETENTION_DAYS] дней. Администратор может изменить этот срок или установить бессрочное хранение (значение 0 или пусто). Сообщения старше установленного срока автоматически удаляются Ботом.
    *   Администраторы могут вручную удалить всю историю сообщений, хранящуюся у Бота для их чата, с помощью команды \`/purge_history\`.
    *   Настройки чата и данные обратной связи хранятся до тех пор, пока Бот установлен в чате или пока не будут удалены вручную.
    
    ## 6. Передача данных третьим лицам
    
    Мы не продаем и не передаем вашу личную информацию третьим лицам в маркетинговых целях. Мы можем передавать некоторые данные следующим категориям третьих лиц только для обеспечения работы Бота:
    
    *   **Google (Gemini API):** Текстовое содержание сообщений и информация из изображений передаются в Google Gemini API для обработки искусственным интеллектом и генерации сводок/комментариев. Передача осуществляется через наш защищенный прокси-сервис. Мы используем стандартные условия использования Google Cloud AI Services.
    *   **Cloudflare (Workers):** Наш прокси-сервис, работающий на Cloudflare Workers, обрабатывает запросы к Google Gemini API и передает ответы обратно Боту. Cloudflare может собирать служебные логи в соответствии со своей политикой конфиденциальности.
    *   **Telegram:** Платформа Telegram обрабатывает все сообщения и взаимодействия с Ботом в соответствии со своей Политикой Конфиденциальности.
    *   **Хостинг-провайдеры:** [Название вашего хостинг-провайдера для сервера Бота, например, Cloud.ru] и [Название хостинг-провайдера для сайта, например, Vercel] могут иметь доступ к техническим логам серверов в соответствии со своими политиками.
    
    Мы требуем от всех третьих лиц, с которыми мы делимся данными, соблюдения конфиденциальности и безопасности ваших данных.
    
    ## 7. Безопасность данных
    
    Мы принимаем разумные технические и организационные меры для защиты собранной информации от несанкционированного доступа, изменения, раскрытия или уничтожения. К таким мерам относятся использование переменных окружения для хранения токенов и ключей API, ограничение доступа к серверам и базе данных. Однако ни один метод передачи данных через Интернет или метод электронного хранения не является на 100% безопасным.
    
    ## 8. Ваши права
    
    В зависимости от вашего местоположения, у вас могут быть определенные права в отношении ваших данных. В рамках функциональности Бота, вы (или администратор вашего чата) можете:
    
    *   Настроить срок хранения сообщений.
    *   Удалить историю сообщений, хранящуюся у Бота, с помощью команды \`/purge_history\`.
    *   Удалить Бота из чата, что приведет к прекращению сбора новых данных для этого чата.
    
    Если вы хотите реализовать другие права (например, доступ, исправление данных) или у вас есть вопросы о ваших данных, пожалуйста, свяжитесь с нами.
    
    ## 9. Конфиденциальность детей
    
    Наш Бот и Сайт не предназначены для использования лицами младше 13 лет (или иного возраста, установленного законодательством вашей страны). Мы сознательно не собираем личную информацию от детей. Если вы считаете, что мы могли получить информацию от ребенка, пожалуйста, свяжитесь с нами.
    
    ## 10. Изменения в Политике Конфиденциальности
    
    Мы можем время от времени обновлять настоящую Политику Конфиденциальности. Мы уведомим вас о любых существенных изменениях, опубликовав новую Политику на Сайте ([Адрес вашего сайта]) и/или через канал поддержки Бота (https://t.me/letopisets_chat_official). Рекомендуется периодически просматривать эту Политику на предмет изменений.
    
    ## 11. Контактная информация
    
    Если у вас есть вопросы по поводу настоящей Политики Конфиденциальности или обработки ваших данных, пожалуйста, свяжитесь с нами:
    
    *   Telegram (разработчик): [https://t.me/nikirO1](https://t.me/nikirO1)
    *   Официальный канал поддержки: [https://t.me/letopisets_chat_official](https://t.me/letopisets_chat_official)
    `, valueEn: `
    # Privacy Policy for "Chat Chronicler" Bot
    
    **Effective Date:** [Date, e.g., April 28, 2025]
    
    ## 1. Introduction
    
    Welcome! This Privacy Policy describes how [Your Name or Project Name] ("we", "us", or "our") collects, uses, and discloses user information ("you") when you use our Telegram bot "Chat Chronicler" ("Bot") and its associated website ([Your Website Address]) ("Site").
    
    By using the Bot or the Site, you agree to the terms of this Privacy Policy. If you do not agree with these terms, please do not use the Bot or the Site. Administrators of Telegram groups who add the Bot to their chats are responsible for informing their chat members about the Bot's operation and this Policy.
    
    ## 2. Information We Collect
    
    The Bot collects the following information to perform its functions:
    
    *   **Information from Group Messages:**
        *   Text content of messages.
        *   Telegram User ID and Username (if available) of the user sending the message.
        *   Chat ID of the group where the Bot is installed.
        *   Timestamp of the message.
        *   Type of message (text, photo, sticker, video, etc.).
        *   File ID and File Unique ID for media files (photos, videos, documents, etc.).
        *   Captions for media files.
    *   **Chat Settings:**
        *   Bot interface language (\`lang\`).
        *   Bot activity status in the chat (\`enabled\`).
        *   Custom summary generation time (\`custom_schedule_time\`).
        *   Chat timezone (\`timezone\`).
        *   Selected genre for "Stories" (\`story_genre\`).
        *   Selected summary format ("Story" or "Digest") (\`output_format\`).
        *   Selected Chronicler personality (\`story_personality\`).
        *   Configured message retention period (\`retention_days\`).
        *   "Interventions" feature settings (\`allow_interventions\`, \`last_intervention_ts\`, \`intervention_cooldown_minutes\`, \`intervention_min_msgs\`, \`intervention_timespan_minutes\`).
    *   **Feedback Data:**
        *   Telegram User ID of the user providing feedback.
        *   Chat ID and Message ID of the message the feedback refers to.
        *   Rating (👍 or 👎).
        *   Timestamp of the feedback.
    *   **Information Transmitted for AI Processing:**
        *   Text content of messages and media captions.
        *   Information from images (processed by the Google Gemini model). Data is transmitted via our proxy service.
    
    ## 3. How We Collect Information
    
    *   Information from messages and user data is collected automatically via the Telegram Bot API when you or other members send messages in a group where the Bot is installed.
    *   Chat settings are collected when using the \`/story_settings\` command and interacting with the settings menu.
    *   Feedback data is collected when you press the 👍/👎 buttons under generated summaries.
    
    ## 4. Purposes of Data Collection and Use
    
    We use the collected information for the following purposes:
    
    *   **Providing Core Bot Functionality:** Generating daily "Stories" or "Digests," creating brief summaries via the \`/summarize\` command, calculating chat statistics via the \`/chat_stats\` command.
    *   **Artificial Intelligence Processing:** Transmitting text and image data (via a proxy service) to the Google Gemini API for analysis and generation of text summaries and comments.
    *   **Personalization:** Applying chat settings (language, time, personality, format, etc.) selected by the administrator.
    *   **"Interventions" Feature:** Generating and sending short comments in the chat (only if this feature is explicitly enabled by the administrator and the configured conditions are met).
    *   **Bot Improvement:** Analyzing feedback data to enhance the quality of generated summaries and Bot performance.
    *   **Support and Diagnostics:** Assisting in troubleshooting issues and errors in the Bot's operation.
    *   **Policy Enforcement:** Monitoring usage to prevent abuse.
    
    ## 5. Data Storage
    
    *   Collected data (messages, settings, feedback) is stored in an SQLite database located on our server ([Specify hosting type/location, e.g., on a Cloud.ru VM in Russia]).
    *   The message retention period is determined by the "Retention Period" setting (\`retention_days\`) in the chat settings. By default, messages are stored for [Your DEFAULT_RETENTION_DAYS value] days. The administrator can change this period or set indefinite storage (value 0 or null). Messages older than the set period are automatically deleted by the Bot.
    *   Administrators can manually delete the entire message history stored by the Bot for their chat using the \`/purge_history\` command.
    *   Chat settings and feedback data are stored as long as the Bot is installed in the chat or until manually deleted.
    
    ## 6. Third-Party Data Sharing
    
    We do not sell or transfer your personal information to third parties for marketing purposes. We may share some data with the following categories of third parties solely to ensure the Bot's operation:
    
    *   **Google (Gemini API):** Text content of messages and information from images are sent to the Google Gemini API for artificial intelligence processing and generation of summaries/comments. Transmission occurs via our secure proxy service. We adhere to the standard terms of use for Google Cloud AI Services.
    *   **Cloudflare (Workers):** Our proxy service, running on Cloudflare Workers, handles requests to the Google Gemini API and relays responses back to the Bot. Cloudflare may collect service logs according to its privacy policy.
    *   **Telegram:** The Telegram platform processes all messages and interactions with the Bot according to its Privacy Policy.
    *   **Hosting Providers:** [Your Bot Server Hosting Provider, e.g., Cloud.ru] and [Your Website Hosting Provider, e.g., Vercel] may have access to technical server logs in accordance with their policies.
    
    We require all third parties with whom we share data to respect the confidentiality and security of your data.
    
    ## 7. Data Security
    
    We take reasonable technical and organizational measures to protect the collected information from unauthorized access, alteration, disclosure, or destruction. Such measures include using environment variables for storing tokens and API keys, and restricting access to servers and databases. However, no method of transmission over the Internet or method of electronic storage is 100% secure.
    
    ## 8. Your Rights
    
    Depending on your location, you may have certain rights regarding your data. Within the Bot's functionality, you (or your chat administrator) can:
    
    *   Configure the message retention period.
    *   Delete the message history stored by the Bot using the \`/purge_history\` command.
    *   Remove the Bot from the chat, which will cease the collection of new data for that chat.
    
    If you wish to exercise other rights (e.g., access, correction) or have questions about your data, please contact us.
    
    ## 9. Children's Privacy
    
    Our Bot and Site are not intended for use by individuals under the age of 13 (or the relevant age in your jurisdiction). We do not knowingly collect personal information from children. If you believe we may have received information from a child, please contact us.
    
    ## 10. Changes to This Privacy Policy
    
    We may update this Privacy Policy from time to time. We will notify you of any significant changes by posting the new Policy on the Site ([Your Website Address]) and/or via the Bot's support channel (https://t.me/letopisets_chat_official). It is recommended to review this Policy periodically for any changes.
    
    ## 11. Contact Information
    
    If you have questions about this Privacy Policy or our data practices, please contact us:
    
    *   Telegram (Developer): [https://t.me/nikirO1](https://t.me/nikirO1)
    *   Official Support Channel: [https://t.me/letopisets_chat_official](https://t.me/letopisets_chat_official)
    ` },

  // FAQ Page (Items as a JSON string)
  { key: 'faq_items', valueRu: JSON.stringify([
    { question: 'Почему боту нужны права администратора?',
      answer: 'Права нужны для чтения сообщений (чтобы анализировать чат и создавать сводки) и для отправки этих сводок в чат. Бот не будет банить пользователей, менять настройки чата или удалять сообщения (кроме как по явной команде администратора `/purge_history`).'
    },
    { question: 'Где хранятся данные моего чата?',
      answer: 'Сообщения и настройки чата хранятся в базе данных SQLite на защищенном сервере [Укажите хостинг, если хотите, напр. Cloud.ru]. Доступ к базе строго ограничен. Данные сообщений и изображений передаются в Google Gemini API через наш защищенный прокси исключительно для генерации текста сводок и не хранятся у Google после обработки.'
    },
    { question: 'Как изменить настройки (время, язык, личность и т.д.)?',
      answer: 'Все настройки доступны по команде `/story_settings` внутри чата, где установлен бот. Эту команду могут использовать только администраторы чата.'
    },
    { question: 'Бот перестал отправлять сводки. Что делать?',
      answer: '1. **Проверьте статус:** Убедитесь, что бот включен для чата командой `/story_settings`. \n2. **Проверьте права:** Убедитесь, что у бота все еще есть права администратора в чате (особенно право читать и отправлять сообщения). \n3. **Попробуйте вручную:** Выполните команду `/generate_now`, чтобы проверить, генерируется ли сводка по запросу. \n4. **Проверьте канал поддержки:** Загляните в наш канал @letopisets_chat_official – возможно, есть информация о временных сбоях.'
    },
    { question: 'Как работают "Вмешательства"? Это безопасно?',
      answer: 'Функция "Вмешательства" позволяет боту (если она включена в `/story_settings`) иногда отправлять короткие комментарии в стиле выбранной Личности, основываясь на последних сообщениях. Это экспериментальная функция для оживления чата. Она не отвечает пользователям напрямую и не должна содержать оскорблений. Вы можете полностью отключить ее или настроить частоту появления в настройках. Используйте на свое усмотрение.'
    },
    { question: 'Бот платный?',
      answer: 'Сам бот предоставляется бесплатно. Однако для генерации текста он использует внешний сервис Google Gemini API. На данный момент использование этого сервиса через бота бесплатно в разумных пределах. В будущем возможны изменения в тарификации API, о чем мы сообщим в канале поддержки.'
    },
    { question: 'Сводка получилась странной или неточной. Почему?',
      answer: 'Качество генерации зависит от возможностей искусственного интеллекта (ИИ) и характера сообщений в вашем чате за день. Иногда ИИ может неправильно интерпретировать контекст или допустить неточности. Пожалуйста, используйте кнопки 👍/👎 под сводкой – ваш фидбек очень важен для улучшения алгоритмов! Также вы можете попробовать пересоздать сводку командой `/regenerate_story`.'
    },
    { question: 'Как удалить историю сообщений, которую хранит бот?',
      answer: 'Администратор чата может использовать команду `/purge_history all` для удаления всей истории или `/purge_history days N`, чтобы удалить сообщения старше N дней. Также в `/story_settings` можно настроить автоматическое удаление старых сообщений по истечении заданного срока (например, 90 дней).'
    }
  ]), valueEn: JSON.stringify([
    { question: 'Why does the bot need admin rights?',
      answer: 'Permissions are needed to read messages (to analyze the chat and create summaries) and to send these summaries to the chat. The bot will not ban users, change chat settings, or delete messages (except via the explicit `/purge_history` command by an admin).'
    },
    { question: 'Where is my chat data stored?',
      answer: 'Messages and chat settings are stored in an SQLite database on a secure server [Specify hosting if desired, e.g., Cloud.ru]. Access to the database is strictly limited. Message and image data is sent to the Google Gemini API via our secure proxy solely for generating summary text and is not retained by Google after processing.'
    },
    { question: 'How to change settings (time, language, personality, etc.)?',
      answer: 'All settings are available via the `/story_settings` command within the chat where the bot is installed. Only chat administrators can use this command.'
    },
    { question: 'The bot stopped sending summaries. What should I do?',
      answer: '1. **Check Status:** Ensure the bot is enabled for the chat using the `/story_settings` command.\n2. **Check Permissions:** Verify that the bot still has administrator rights in the chat (especially the rights to read and send messages).\n3. **Try Manually:** Execute the `/generate_now` command to see if a summary is generated on demand.\n4. **Check Support Channel:** Look at our channel @letopisets_chat_official – there might be information about temporary outages.'
    },
    { question: 'How do "Interventions" work? Is it safe?',
      answer: '"Interventions" is an optional feature (enabled via `/story_settings`) that allows the bot to occasionally send short comments in the style of the selected Personality, based on recent messages. It\'s an experimental feature to liven up the chat. It doesn\'t reply directly to users and should not contain insults. You can disable it entirely or configure its frequency in the settings. Use at your discretion.'
    },
    { question: 'Is the bot free?',
      answer: 'The bot itself is provided free of charge. However, it uses the external Google Gemini API for text generation. Currently, using this service through the bot is free within reasonable limits. API pricing might change in the future, and we will announce any changes in the support channel.'
    },
    { question: 'The summary seems weird or inaccurate. Why?',
      answer: 'The generation quality depends on the Artificial Intelligence (AI) capabilities and the nature of the messages in your chat for that day. Sometimes the AI might misinterpret context or make inaccuracies. Please use the 👍/👎 buttons under the summary – your feedback is crucial for improving the algorithms! You can also try regenerating the summary with the `/regenerate_story` command.'
    },
    { question: 'How to delete the message history stored by the bot?',
      answer: 'A chat administrator can use the `/purge_history all` command to delete the entire history or `/purge_history days N` to delete messages older than N days. You can also configure automatic deletion of old messages after a set period (e.g., 90 days) in `/story_settings`.'
    }
  ]) },
  // ... добавьте ВСЕ ОСТАЛЬНЫЕ ключи, используемые в t() ...
];

const featuresData = [
  // ЗАПОЛНИТЕ РЕАЛЬНЫМИ ОПИСАНИЯМИ
  { titleRu: 'Истории и Дайджесты', titleEn: 'Stories & Digests', descriptionRu: 'Бот создает ежедневные сводки в виде связной истории или краткого дайджеста.', descriptionEn: 'The bot creates daily summaries as a coherent story or a concise digest.', icon: 'BookOpen', order: 1 },
  { titleRu: 'Личности ИИ', titleEn: 'AI Personalities', descriptionRu: 'Выберите, кто будет писать сводку: Мудрец, Поэт, Саркаст или Нейтральный наблюдатель.', descriptionEn: 'Choose who writes the summary: Wise Elder, Poet, Sarcastic Observer, or Neutral narrator.', icon: 'UserCircle', order: 2 },
  { titleRu: 'Анализ Изображений', titleEn: 'Image Analysis', descriptionRu: 'Летописец может "видеть" изображения и учитывать их при составлении сводки.', descriptionEn: 'The Chronicler can "see" images and consider them when creating the summary.', icon: 'Image', order: 3 },
  { titleRu: 'Статистика Чата', titleEn: 'Chat Statistics', descriptionRu: 'Получите статистику активности: топ пользователей, количество сообщений, фото, стикеров.', descriptionEn: 'Get activity statistics: top users, message counts, photos, stickers.', icon: 'BarChart', order: 4 },
  { titleRu: 'Гибкая Настройка', titleEn: 'Flexible Settings', descriptionRu: 'Настройте время, язык, формат, личность, срок хранения и другие параметры под ваш чат.', descriptionEn: 'Customize time, language, format, personality, retention period, and other parameters for your chat.', icon: 'Settings', order: 5 },
  // ... добавьте другие фичи, если есть ...
];

const examplesData = [
  // ЗАПОЛНИТЕ РЕАЛЬНЫМИ ПРИМЕРАМИ ТЕКСТА
  { personalityRu: 'Мудрец', personalityEn: 'Wise Elder', contentRu: 'День прошел в размышлениях о вечном и обсуждении планов на выходные. Помните, что путь в тысячу ли начинается с одного шага...', contentEn: 'The day passed in contemplation of the eternal and discussion of weekend plans. Remember, the journey of a thousand miles begins with a single step...', order: 1 },
  { personalityRu: 'Саркастичный Наблюдатель', personalityEn: 'Sarcastic Observer', contentRu: 'Уровень прокрастинации достиг новых высот, сопровождаемый активным обменом мемами. Кажется, продуктивность сегодня не в приоритете.', contentEn: 'Procrastination levels reached new heights, accompanied by active meme exchange. Productivity seems not to be a priority today.', order: 2 },
  { personalityRu: 'Поэт-Романтик', personalityEn: 'Romantic Poet', contentRu: 'Словно бабочки, идеи порхали в чате, оставляя легкий след вдохновения. Вечер окутал беседу теплым пледом уюта.', contentEn: 'Like butterflies, ideas fluttered through the chat, leaving a light trail of inspiration. The evening wrapped the conversation in a warm blanket of comfort.', order: 3 },
  { personalityRu: 'Нейтральный', personalityEn: 'Neutral', contentRu: 'В течение дня обсуждались рабочие задачи X и Y. Пользователь А поделился ссылкой на статью. Активность была средней.', contentEn: 'During the day, work tasks X and Y were discussed. User A shared a link to an article. Activity was moderate.', order: 4 },
  // ... добавьте другие примеры, если есть ...
];

// ============================================================================
// --- Логика Сидинга ---
// ============================================================================

async function main() {
  console.log(`Start seeding ...`);

  // Seed Content
  console.log('Seeding Content...');
  for (const item of contentData) {
    try {
        const content = await prisma.content.upsert({
          where: { key: item.key },
          update: { valueRu: item.valueRu, valueEn: item.valueEn },
          create: item,
        });
        console.log(`  Upserted content key: ${content.key}`);
    } catch(error) {
        console.error(`  Failed to upsert content key ${item.key}:`, error)
    }
  }

  // Seed Features
  console.log('Seeding Features...');
  for (const item of featuresData) {
     try {
        // Используем order как уникальный идентификатор для upsert
        const feature = await prisma.feature.upsert({
          where: { order: item.order }, // Убедитесь, что order уникален!
          update: {
              titleRu: item.titleRu, titleEn: item.titleEn,
              descriptionRu: item.descriptionRu, descriptionEn: item.descriptionEn,
              icon: item.icon
          },
          create: item,
        });
        console.log(`  Upserted feature order ${feature.order}: ${feature.titleEn}`);
    } catch(error) {
        console.error(`  Failed to upsert feature order ${item.order}:`, error)
    }
  }

  // Seed Examples
  console.log('Seeding Examples...');
  for (const item of examplesData) {
    try {
        // Используем order как уникальный идентификатор для upsert
        const example = await prisma.example.upsert({
          where: { order: item.order }, // Убедитесь, что order уникален!
           update: {
              personalityRu: item.personalityRu, personalityEn: item.personalityEn,
              contentRu: item.contentRu, contentEn: item.contentEn
           },
          create: item,
        });
        console.log(`  Upserted example order ${example.order}: ${example.personalityEn}`);
     } catch(error) {
        console.error(`  Failed to upsert example order ${item.order}:`, error)
    }
  }

  console.log(`Seeding finished.`);
}

main()
  .catch((e) => {
    console.error("Error during seeding:", e);
    process.exit(1);
  })
  .finally(async () => {
    console.log('Disconnecting Prisma Client...');
    await prisma.$disconnect();
  });

--- END OF FILE: prisma/seed.ts ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/globals.css ---

/* src/app/globals.css - Модифицированная версия рабочего файла */

/* 1. Стандартные директивы Tailwind (вместо @import "tailwindcss") */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 2. Нестандартная директива для темной темы (оставляем, т.к. работало) */
@custom-variant dark (&:is(.dark *));

/* 3. Нестандартная директива для inline темы (оставляем, т.к. работало) */
@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans); /* Убедитесь, что этот шрифт подключен */
  --font-mono: var(--font-geist-mono); /* Убедитесь, что этот шрифт подключен */
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

/* 4. Определение CSS переменных для тем (OKLCH из рабочего файла) */
/* Слой @layer base используется для установки дефолтов Tailwind */
@layer base {
  /* Переменные для светлой темы (если она нужна как fallback) */
  :root {
    --radius: 0.625rem; /* Немного увеличен радиус */
    --background: oklch(1 0 0); /* white */
    --foreground: oklch(0.145 0 0); /* near black */
    --card: oklch(1 0 0);
    --card-foreground: oklch(0.145 0 0);
    --popover: oklch(1 0 0);
    --popover-foreground: oklch(0.145 0 0);
    --primary: oklch(0.205 0 0);
    --primary-foreground: oklch(0.985 0 0);
    --secondary: oklch(0.97 0 0);
    --secondary-foreground: oklch(0.205 0 0);
    --muted: oklch(0.97 0 0);
    --muted-foreground: oklch(0.556 0 0);
    --accent: oklch(0.97 0 0);
    --accent-foreground: oklch(0.205 0 0);
    --destructive: oklch(0.577 0.245 27.325);
    --border: oklch(0.922 0 0);
    --input: oklch(0.922 0 0);
    --ring: oklch(0.708 0 0); /* Был oklch(0.708 0 0), можно использовать цвет primary для кольца */
    /* --ring: var(--primary); */ /* Альтернатива */
    --chart-1: oklch(0.646 0.222 41.116);
    --chart-2: oklch(0.6 0.118 184.704);
    --chart-3: oklch(0.398 0.07 227.392);
    --chart-4: oklch(0.828 0.189 84.429);
    --chart-5: oklch(0.769 0.188 70.08);
    --sidebar: oklch(0.985 0 0);
    --sidebar-foreground: oklch(0.145 0 0);
    --sidebar-primary: oklch(0.205 0 0);
    --sidebar-primary-foreground: oklch(0.985 0 0);
    --sidebar-accent: oklch(0.97 0 0);
    --sidebar-accent-foreground: oklch(0.205 0 0);
    --sidebar-border: oklch(0.922 0 0);
    --sidebar-ring: oklch(0.708 0 0);

    /* Переменные для шрифтов (если используются) */
    --font-geist-sans: "Geist Variable", sans-serif; /* Пример подключения */
    --font-geist-mono: "Geist Mono Variable", monospace; /* Пример подключения */
  }

  /* Переменные для темной темы */
  .dark {
    --background: 224 71% 4%; /* Используем HSL для совместимости с shadcn по умолчанию */
    --foreground: 210 40% 98%;
    --card: 224 71% 9%;
    --card-foreground: 210 40% 98%;
    --popover: 224 71% 4%;
    --popover-foreground: 210 40% 98%;
    --primary: 217 91% 60%;
    --primary-foreground: 210 40% 98%; /* Изменено для лучшего контраста */
    --secondary: 217 33% 17%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217 33% 17%;
    --muted-foreground: 215 20% 65%;
    --accent: 217 33% 17%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 63% 40%;
    --destructive-foreground: 210 40% 98%;
    --border: 217 33% 25%;
    --input: 217 33% 25%;
    --ring: 217 91% 70%; /* Более светлое кольцо фокуса */
    /* Переменные chart и sidebar из рабочего CSS */
    --chart-1: oklch(0.488 0.243 264.376);
    --chart-2: oklch(0.696 0.17 162.48);
    --chart-3: oklch(0.769 0.188 70.08);
    --chart-4: oklch(0.627 0.265 303.9);
    --chart-5: oklch(0.645 0.246 16.439);
    --sidebar: oklch(0.205 0 0);
    --sidebar-foreground: oklch(0.985 0 0);
    --sidebar-primary: oklch(0.488 0.243 264.376);
    --sidebar-primary-foreground: oklch(0.985 0 0);
    --sidebar-accent: oklch(0.269 0 0);
    --sidebar-accent-foreground: oklch(0.985 0 0);
    --sidebar-border: oklch(1 0 0 / 10%);
    --sidebar-ring: oklch(0.556 0 0);
  }
}

/* 5. Базовые стили для элементов */
@layer base {
  * {
    /* Применяем цвет границы */
    @apply border-border;
    /* Убираем стандартный outline, если он мешает кастомному --ring */
    /* outline: none; */
  }
  html {
    scroll-behavior: smooth; /* Плавная прокрутка */
  }
  body {
    /* Применяем фон, цвет текста, шрифт и сглаживание */
    @apply bg-background text-foreground min-h-screen antialiased;
    /* Применение шрифта, если переменная определена */
    /* font-family: var(--font-geist-sans, sans-serif); */
    font-feature-settings: "rlig" 1, "calt" 1;
  }

  /* Стилизация скроллбара для темной темы */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  ::-webkit-scrollbar-track {
    background: hsl(var(--background) / 0.5); /* Полупрозрачный фон */
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb {
    background: hsl(var(--border)); /* Цвет границы */
    border-radius: 4px;
    border: 1px solid hsl(var(--background)); /* Обводка цветом фона */
  }
  ::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--muted-foreground)); /* Цвет при наведении */
  }
}

--- END OF FILE: src/app/globals.css ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/layout.tsx ---

// src/app/layout.tsx
import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { Providers } from "./providers"; // Путь к вашему файлу провайдеров
import SiteLayout from "./_components/SiteLayout"; // Путь к вашему макету

const inter = Inter({ subsets: ["latin"] }); // Или ваш выбранный шрифт

export const metadata: Metadata = {
  title: "Летописец Чата | Chat Chronicler", // Можно сделать динамическим
  description: "Ваш ИИ-ассистент для Telegram-групп, который анализирует историю сообщений и генерирует уникальные сводки дня.",
  viewport: 'width=device-width, initial-scale=1',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    // Применяем темный класс и язык по умолчанию (провайдер может его изменить)
    <html lang="en" className="dark" suppressHydrationWarning>
      <body className={`${inter.className} antialiased`}>
        <Providers>
          <SiteLayout>
            {children}
          </SiteLayout>
        </Providers>
      </body>
    </html>
  );
}

--- END OF FILE: src/app/layout.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/providers.tsx ---

"use client"; // Этот компонент будет управлять клиентскими провайдерами

import { ReactNode } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// Важно: Не используйте ReactQueryDevtools в продакшене без необходимости
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { LanguageProvider } from './_components/LanguageProvider'; // Укажите правильный путь

// Создаем функцию для безопасного создания QueryClient только один раз
function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // Отключаем автоматический refetch при монтировании, если не нужно
        // refetchOnMount: false,
        refetchOnWindowFocus: false,
        // refetchOnReconnect: false,
        retry: 1, // 1 попытка повтора по умолчанию
        staleTime: 1000 * 60 * 5, // 5 минут по умолчанию staleTime
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (typeof window === 'undefined') {
    // Server: всегда создаем новый клиент
    return makeQueryClient();
  } else {
    // Browser: используем существующий клиент или создаем новый
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}


export function Providers({ children }: { children: ReactNode }) {
  // Получаем или создаем экземпляр QueryClient безопасным способом
  const queryClient = getQueryClient();

  return (
    // Предоставляем queryClient для всего приложения
    <QueryClientProvider client={queryClient}>
      {/* LanguageProvider теперь находится внутри QueryClientProvider */}
      <LanguageProvider>
        {children}
      </LanguageProvider>
      {/* Опционально: Инструменты разработчика для React Query (только в разработке) */}
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
}

--- END OF FILE: src/app/providers.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/api/content/route.ts ---

// src/app/api/content/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function GET() {
  try {
    // Параллельно запрашиваем данные
    const [content, features, examples] = await Promise.all([
      prisma.content.findMany(),
      prisma.feature.findMany({ orderBy: { order: 'asc' } }), // Сортируем по order
      prisma.example.findMany({ orderBy: { order: 'asc' } }), // Сортируем по order
    ]);

    // Формируем ответ
    const responseData = {
      content,
      features,
      examples,
    };

    // Возвращаем JSON
    return NextResponse.json(responseData);

  } catch (error) {
    console.error("API Error fetching content:", error);
    return NextResponse.json(
      { error: "Failed to fetch content" },
      { status: 500 }
    );
  } finally {
    await prisma.$disconnect(); // Закрываем соединение
  }
}

--- END OF FILE: src/app/api/content/route.ts ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/faq/page.tsx ---

// src/app/faq/page.tsx
"use client";

import React from "react";
import { useLanguage } from "../_components/LanguageProvider";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Button } from "~/components/ui/button";
import { HelpCircle, MessageSquare, Send } from "lucide-react";
import { Skeleton } from "~/components/ui/skeleton"; // Для лоадера

interface FaqItem {
  question: string;
  answer: string;
}

export default function FaqPage() {
  const { t, language, content, isLoadingContent } = useLanguage();

  // Парсим FAQ из строки JSON
  let faqItems: FaqItem[] = [];
  const faqItemsContent = content.find((c) => c.key === "faq_items");

  // Парсим только если контент загружен
  if (!isLoadingContent && faqItemsContent) {
    try {
      const parsedData = JSON.parse(
        language === "ru" ? faqItemsContent.valueRu : faqItemsContent.valueEn
      );
      if (Array.isArray(parsedData) && parsedData.every(item => typeof item === 'object' && 'question' in item && 'answer' in item)) {
        faqItems = parsedData as FaqItem[];
      } else {
         console.error("Parsed FAQ data is not a valid array of {question, answer} objects.");
      }
    } catch (e) {
      console.error("Error parsing FAQ items JSON:", e);
    }
  }

   const supportChannelLink = t('support_channel_link', '#');
   const developerContactLink = t('developer_contact_link', '#');
   const feedbackContactLink = t('feedback_contact_link', developerContactLink); // Ссылка для фидбека = ссылка на разработчика по умолчанию

    if (isLoadingContent && faqItems.length === 0) {
       // Лоадер для FAQ
        return (
            <div className="container mx-auto px-4 py-16">
                 <Skeleton className="h-10 w-1/2 md:w-1/3 mx-auto mb-12" />
                 <div className="max-w-4xl mx-auto grid gap-12 lg:grid-cols-3">
                     <div className="lg:col-span-2 space-y-6">
                         <Skeleton className="h-6 w-1/3 mb-6" />
                         {[...Array(4)].map((_, i) => <Skeleton key={i} className="h-32 w-full rounded-lg" />)}
                     </div>
                     <div className="lg:col-span-1 space-y-6">
                         <Skeleton className="h-40 w-full rounded-lg" />
                         <Skeleton className="h-40 w-full rounded-lg" />
                    </div>
                </div>
            </div>
        );
    }

  return (
    <div className="container mx-auto px-4 py-16">
       <h1 className="text-3xl md:text-4xl font-bold mb-12 text-center">
         {t('faq_page_title', language === "ru" ? "Поддержка / FAQ" : "Support / FAQ")}
       </h1>

       <div className="max-w-4xl mx-auto grid gap-12 lg:grid-cols-3">

         {/* FAQ Section */}
         <section className="lg:col-span-2 space-y-6">
           <h2 className="text-2xl font-bold mb-6 flex items-center gap-2">
             <HelpCircle className="h-6 w-6 text-primary"/>
             {t('faq_section_title', language === "ru" ? "Часто Задаваемые Вопросы" : "Frequently Asked Questions")}
          </h2>
          {faqItems.length > 0 ? (
            faqItems.map((item, index) => (
              <Card key={index} className="bg-card border-border shadow-sm">
                 <CardHeader className="pb-3"> {/* Уменьшим паддинг снизу */}
                   <CardTitle className="text-lg font-semibold">{item.question}</CardTitle>
                 </CardHeader>
                 <CardContent>
                    {/* Используем div и map для рендеринга параграфов, если в ответе есть переносы строк */}
                    <div className="text-muted-foreground text-sm leading-relaxed space-y-2">
                     {item.answer.split('\n').map((line, i) => line.trim() && <p key={i}>{line}</p>)}
                   </div>
                 </CardContent>
              </Card>
            ))
          ) : (
              <Card className="bg-card border-border shadow-sm">
                  <CardContent className="pt-6">
                    <p className="text-muted-foreground text-center">{t('faq_loading_or_error', language === 'ru' ? 'Вопросы загружаются или не найдены...' : 'Questions are loading or not found...')}</p>
                  </CardContent>
              </Card>
          )}
        </section>

         {/* Support Section */}
         <aside className="lg:col-span-1 space-y-6">
            {/* Support Channel Card */}
           <Card className="bg-card border-border shadow-sm">
             <CardHeader>
                 <CardTitle className="text-lg font-semibold flex items-center gap-2">
                    <MessageSquare className="h-5 w-5 text-primary"/>
                    {t('support_channel_card_title', language === "ru" ? "Канал поддержки" : "Support Channel")}
                </CardTitle>
             </CardHeader>
            <CardContent>
               <p className="mb-4 text-sm text-muted-foreground">
                 {t('support_channel_card_text', language === "ru" ? "Присоединяйтесь к нашему официальному каналу для новостей, анонсов и обсуждений." : "Join our channel for news, announcements, and discussions.")}
               </p>
                {supportChannelLink && supportChannelLink !== '#' && supportChannelLink !== '[support_channel_link]' && (
                    <Button asChild className="w-full" size="sm">
                      <a href={supportChannelLink} target="_blank" rel="noopener noreferrer">
                        {t('support_channel_button', language === "ru" ? "Перейти в Канал" : "Go to Channel")}
                      </a>
                    </Button>
                )}
            </CardContent>
          </Card>

            {/* Contact Developer Card */}
           <Card className="bg-card border-border shadow-sm">
             <CardHeader>
                 <CardTitle className="text-lg font-semibold flex items-center gap-2">
                    <Send className="h-5 w-5 text-primary"/>
                   {t('developer_contact_card_title', language === "ru" ? "Связаться с Разработчиком" : "Contact Developer")}
                </CardTitle>
             </CardHeader>
            <CardContent>
               <p className="mb-4 text-sm text-muted-foreground">
                 {t('developer_contact_card_text', language === "ru" ? "Есть идеи, предложения или нашли ошибку? Напишите напрямую." : "Have ideas, suggestions, or found a bug? Contact directly.")}
               </p>
                 {developerContactLink && developerContactLink !== '#' && developerContactLink !== '[developer_contact_link]' && (
                    <Button asChild className="w-full" size="sm">
                      <a href={developerContactLink} target="_blank" rel="noopener noreferrer">
                        {t('developer_contact_button', language === "ru" ? "Написать Сообщение" : "Send Message")}
                      </a>
                    </Button>
                )}
            </CardContent>
          </Card>

           {/* Feedback Section (внутри aside) */}
            <Card className="bg-muted border-border shadow-sm">
                 <CardHeader>
                    <CardTitle className="text-lg font-semibold">
                        {t('feedback_card_title', language === "ru" ? "Предложить идею / Сообщить об ошибке" : "Suggest an Idea / Report a Bug")}
                    </CardTitle>
                </CardHeader>
                 <CardContent>
                    <p className="mb-4 text-sm text-muted-foreground">
                        {t('feedback_card_text', language === "ru" ? "Ваша обратная связь помогает нам улучшать Летописца Чата." : "Your feedback helps us improve Chat Chronicler.")}
                    </p>
                     {feedbackContactLink && feedbackContactLink !== '#' && feedbackContactLink !== '[feedback_contact_link]' && (
                        <Button asChild className="w-full" size="sm">
                            <a href={feedbackContactLink} target="_blank" rel="noopener noreferrer">
                                {t('feedback_button', language === "ru" ? "Отправить отзыв" : "Send Feedback")}
                            </a>
                        </Button>
                     )}
                </CardContent>
             </Card>
        </aside>

      </div>
    </div>
  );
}

--- END OF FILE: src/app/faq/page.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/features/page.tsx ---

// src/app/features/page.tsx
"use client";

import React from "react";
import { useLanguage, iconMap } from "../_components/LanguageProvider"; // Путь к вашим компонентам
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Skeleton } from "~/components/ui/skeleton"; // Импортируем Skeleton для лоадера

export default function FeaturesPage() {
  // Получаем данные и статус загрузки
  const { t, language, features, isLoadingContent } = useLanguage();

  // Отображение скелетонов во время загрузки
  if (isLoadingContent) {
    return (
      <div className="container mx-auto px-4 py-16">
        <Skeleton className="h-10 w-1/2 md:w-1/3 mx-auto mb-12" /> {/* Скелетон для заголовка */}
        <div className="grid gap-8 md:grid-cols-2 lg:grid-cols-3">
          {[...Array(6)].map((_, index) => ( // Рендерим 6 скелетонов карточек
            <Card key={index} className="border-border shadow-sm">
              <CardHeader>
                <div className="flex items-center gap-3 mb-2">
                  <Skeleton className="h-6 w-6 rounded-full" />
                  <Skeleton className="h-6 w-2/4" />
                </div>
              </CardHeader>
              <CardContent className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-5/6" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  // Отображение реальных данных
  return (
    <div className="bg-muted border-t border-b border-border"> {/* Фон как у секции на главной */}
      <div className="container mx-auto px-4 py-16 md:py-20"> {/* Отступы */}
        <h1 className="text-3xl md:text-4xl font-bold mb-12 text-center">
          {t("features_title", "Key Features")} {/* Заголовок страницы */}
        </h1>

        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3 items-stretch"> {/* items-stretch чтобы карточки были одной высоты */}
          {features.length > 0 ? (
              features.map((feature) => (
               // Каждая фича в отдельной карточке
               <Card key={feature.id} className="bg-card border-border shadow-sm flex flex-col hover:shadow-lg transition-shadow duration-300">
                   <CardHeader>
                      <div className="flex items-center gap-3 mb-1">
                        {/* Иконка фичи */}
                        <span className="text-primary"> {/* Цвет иконки */}
                          {iconMap[feature.icon] || iconMap.Default}
                        </span>
                        {/* Заголовок фичи */}
                        <CardTitle className="text-xl font-semibold">
                          {language === "ru" ? feature.titleRu : feature.titleEn}
                        </CardTitle>
                      </div>
                  </CardHeader>
                   <CardContent className="flex-grow"> {/* Контент занимает оставшееся место */}
                      {/* Описание фичи */}
                      <p className="text-muted-foreground leading-relaxed">
                        {language === "ru" ? feature.descriptionRu : feature.descriptionEn}
                      </p>
                  </CardContent>
               </Card>
              ))
          ) : (
              // Сообщение, если фичи не загружены
              <p className="text-center text-muted-foreground md:col-span-2 lg:col-span-3 py-10">
                 {t('features_not_loaded', language === 'ru' ? 'Возможности пока не загружены...' : 'Features not loaded yet...')}
              </p>
          )}
        </div>
      </div>
    </div>
  );
}

--- END OF FILE: src/app/features/page.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/privacy/page.tsx ---

// src/app/privacy/page.tsx
"use client";

import React from "react";
import ReactMarkdown from "react-markdown"; // Импортируем компонент для рендеринга Markdown
import remarkGfm from 'remark-gfm'; // Импортируем плагин для поддержки GitHub Flavored Markdown (таблицы, ссылки и т.д.)
import { Button } from "~/components/ui/button"; // Компонент кнопки
import { useLanguage } from "../_components/LanguageProvider"; // Хук для получения языка и текстов
import { Skeleton } from "~/components/ui/skeleton"; // Компонент для отображения загрузки
import { Card, CardContent } from "~/components/ui/card"; // Обертка для контента

export default function PrivacyPage() {
  // Получаем функцию перевода t, текущий язык и статус загрузки контента
  const { t, language, isLoadingContent } = useLanguage();

  // Получаем полный текст политики конфиденциальности для текущего языка
  // Используем пустую строку как fallback, если ключ не найден или контент еще грузится
  const privacyContent = t("privacy_policy_text", "");

  // Получаем ссылки для кнопок контактов, используем '#' как fallback
  const supportChannelLink = t('support_channel_link', '#');
  const developerContactLink = t('developer_contact_link', '#');

  // Отображаем скелетон/лоадер, пока контент загружается
  if (isLoadingContent && !privacyContent) {
    return (
      <div className="container mx-auto px-4 py-16">
        {/* Скелетон заголовка */}
        <Skeleton className="h-10 w-1/2 md:w-1/3 mx-auto mb-12 rounded-md" />
        {/* Скелетон для карточки с контентом */}
        <div className="max-w-4xl mx-auto bg-card p-6 md:p-10 rounded-lg shadow-md border border-border">
          <div className="space-y-4">
            <Skeleton className="h-6 w-1/4 rounded-md" />
            <Skeleton className="h-4 w-full rounded-md" />
            <Skeleton className="h-4 w-5/6 rounded-md" />
            <Skeleton className="h-4 w-full rounded-md" />
            <br />
            <Skeleton className="h-6 w-1/3 rounded-md" />
            <Skeleton className="h-4 w-full rounded-md" />
            <Skeleton className="h-4 w-full rounded-md" />
            <Skeleton className="h-4 w-3/4 rounded-md" />
            <br />
             {/* Скелетон для секции контактов */}
            <Skeleton className="h-6 w-1/3 mt-10 pt-6 border-t border-border rounded-md" />
            <Skeleton className="h-4 w-2/3 rounded-md" />
            <div className="flex flex-col sm:flex-row gap-3 pt-4">
               <Skeleton className="h-10 w-36 rounded-md" />
               <Skeleton className="h-10 w-48 rounded-md" />
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Отображаем реальную страницу после загрузки контента
  return (
    <div className="container mx-auto px-4 py-16"> {/* Основной контейнер страницы */}
      {/* Заголовок страницы */}
      <h1 className="text-3xl md:text-4xl font-bold mb-10 text-center text-foreground">
        {t("privacy_policy_title", "Privacy Policy")}
      </h1>

      {/* Карточка для основного контента политики */}
      <Card className="max-w-4xl mx-auto bg-card p-6 md:p-10 rounded-lg shadow-md border border-border">
        <CardContent className="p-0"> {/* Убираем стандартный padding CardContent */}
          {/* Контейнер для стилизации Markdown с помощью плагина @tailwindcss/typography */}
          <div
            className="prose prose-sm sm:prose-base dark:prose-invert
                       prose-headings:font-semibold prose-headings:text-foreground prose-headings:border-b prose-headings:border-border prose-headings:pb-2 prose-headings:mb-4
                       prose-p:text-muted-foreground prose-p:leading-relaxed prose-p:my-3
                       prose-a:text-primary hover:prose-a:text-primary/80 prose-a:font-medium prose-a:no-underline hover:prose-a:underline
                       prose-strong:text-foreground prose-strong:font-semibold
                       prose-ul:list-disc prose-ul:pl-5 prose-li:text-muted-foreground prose-li:my-1.5
                       prose-blockquote:border-l-4 prose-blockquote:border-primary prose-blockquote:pl-4 prose-blockquote:italic prose-blockquote:text-muted-foreground
                       prose-code:text-foreground prose-code:font-mono prose-code:text-sm prose-code:before:content-[''] prose-code:after:content-[''] prose-code:bg-muted prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded
                       max-w-none" // Обязательно для применения стилей на всю ширину внутри Card
          >
            {/* Рендеринг Markdown текста политики */}
            <ReactMarkdown remarkPlugins={[remarkGfm]}>{privacyContent}</ReactMarkdown>
          </div>

          {/* Секция контактов */}
          <div className="mt-10 pt-6 border-t border-border">
            <h2 className="text-xl font-semibold mb-4 text-foreground">
              {t('contact_info_title', language === "ru" ? "Контактная информация" : "Contact Information")}
            </h2>
            <p className="text-muted-foreground mb-5"> {/* Увеличен отступ снизу */}
              {t('contact_info_text', language === "ru" ? "Если у вас есть вопросы по поводу политики конфиденциальности, свяжитесь с нами:" : "If you have questions about this privacy policy, please contact us:")}
            </p>
            {/* Кнопки контактов */}
            <div className="flex flex-col sm:flex-row gap-3">
              {/* Кнопка канала поддержки */}
              {supportChannelLink && supportChannelLink !== '#' && supportChannelLink !== '[support_channel_link]' && (
                  <Button asChild variant="outline" className="bg-background border-border hover:bg-accent">
                    <a href={supportChannelLink} target="_blank" rel="noopener noreferrer">
                      {t('support_channel_button', language === "ru" ? "Канал поддержки" : "Support Channel")}
                    </a>
                  </Button>
              )}
              {/* Кнопка связи с разработчиком */}
              {developerContactLink && developerContactLink !== '#' && developerContactLink !== '[developer_contact_link]' && (
                  <Button asChild variant="outline" className="bg-background border-border hover:bg-accent">
                    <a href={developerContactLink} target="_blank" rel="noopener noreferrer">
                      {t('developer_contact_button', language === "ru" ? "Связаться с разработчиком" : "Contact Developer")}
                    </a>
                  </Button>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

--- END OF FILE: src/app/privacy/page.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/setup/page.tsx ---

// src/app/setup/page.tsx
"use client";

import React, { useState } from "react";
import { QRCodeSVG } from "qrcode.react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { useLanguage } from "../_components/LanguageProvider";
import { Skeleton } from "~/components/ui/skeleton"; // Для лоадера

export default function SetupPage() {
  const { t, language, isLoadingContent } = useLanguage();
  const [showQrEnlarged, setShowQrEnlarged] = useState(false);

  const botUsername = t("telegram_bot_username", "LetopisetsChatBot");
  const telegramLink = `https://t.me/${botUsername}?startgroup=true`;


  if (isLoadingContent) {
     // Простой лоадер для страницы установки
    return (
      <div className="container mx-auto px-4 py-16">
        <Skeleton className="h-10 w-1/2 md:w-1/3 mx-auto mb-8" />
        <Skeleton className="h-6 w-3/4 md:w-1/2 mx-auto mb-12" />
         <div className="flex flex-col md:flex-row justify-center items-start md:items-center gap-8 mb-12">
            <Skeleton className="w-48 h-48 rounded-lg" />
            <Skeleton className="w-48 h-12 rounded-lg" />
        </div>
        <div className="max-w-2xl mx-auto space-y-6">
           <Skeleton className="h-40 w-full rounded-lg" />
           <Skeleton className="h-40 w-full rounded-lg" />
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-16">
      <h1 className="text-3xl md:text-4xl font-bold mb-8 text-center">
        {t("setup_title", "Setup & Configuration")}
      </h1>
      <p className="text-lg mb-10 text-center text-muted-foreground max-w-2xl mx-auto">{t("setup_intro")}</p>

       {/* Секция с QR и копированием */}
       <div className="flex flex-col items-center mb-16"> {/* Центрируем все содержимое по горизонтали, увеличиваем нижний отступ */}

        <h2 className="text-xl md:text-2xl font-semibold mb-3 text-center">
          {t('qr_code_title_centered', language === "ru" ? "Быстрый старт с QR" : "Quick Start with QR")}
        </h2>
        <p className="text-center text-muted-foreground mb-6 max-w-md"> {/* Увеличиваем нижний отступ и максимальную ширину */}
          {t('qr_code_subtitle_centered', language === "ru" ? "Наведите камеру вашего телефона на QR-код, чтобы быстро добавить Летописца Чата в вашу Telegram-группу." : "Point your phone's camera at the QR code to quickly add Chat Chronicler to your Telegram group.")}
        </p>

        {/* Контейнер для QR-кода */}
        <div
          className="bg-white p-4 rounded-lg cursor-pointer mb-2 shadow-lg hover:shadow-xl transition-shadow duration-300 inline-block" // Увеличиваем padding и тень
          onClick={() => setShowQrEnlarged(!showQrEnlarged)}
          title={t('qr_code_enlarge_title', language === 'ru' ? 'Нажмите для увеличения' : 'Click to enlarge')}
        >
          <QRCodeSVG
            value={telegramLink}
            size={showQrEnlarged ? 250 : 160} // Увеличиваем базовый размер
            level="H"
            includeMargin={false} // Убираем лишнюю рамку
            bgColor="#ffffff"
            fgColor="#0B1120" // Темный цвет модулей
          />
        </div>
        <p className="text-sm text-muted-foreground"> {/* Текст подсказки */}
          {t('qr_code_enlarge_hint', language === "ru" ? "(Нажмите для увеличения)" : "(Click to enlarge)")}
        </p>

      </div>


      {/* Пошаговая инструкция */}
      <div className="max-w-2xl mx-auto">
        <h2 className="text-2xl font-bold mb-8 text-center"> {/* Увеличен отступ снизу */}
            {t('step_by_step_title', language === 'ru' ? 'Пошаговая инструкция' : 'Step-by-Step Guide')}
        </h2>
        <div className="space-y-6">
          {/* Шаг 1 */}
          <Card className="bg-card border-border shadow-sm">
            <CardHeader><CardTitle className="flex items-center gap-3">
               <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-semibold">1</div>
               <span className="text-lg">{t("step1_title")}</span>
            </CardTitle></CardHeader>
            <CardContent>
              <p className="mb-4 text-muted-foreground">{t("step1_text")}</p>
              <Button asChild size="sm">
                 <a href={telegramLink} target="_blank" rel="noopener noreferrer">
                   {t("cta_button")}
                 </a>
              </Button>
            </CardContent>
          </Card>
          {/* Шаг 2 */}
          <Card className="bg-card border-border shadow-sm">
             <CardHeader><CardTitle className="flex items-center gap-3">
               <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-semibold">2</div>
                <span className="text-lg">{t("step2_title")}</span>
            </CardTitle></CardHeader>
            <CardContent>
               <p className="mb-4 text-muted-foreground">{t("step2_text")}</p>
               <div className="bg-muted/50 p-4 rounded-lg border">
                  <h3 className="font-semibold mb-2 text-base">{t("setup_permissions_title")}</h3> {/* Уменьшил h3 */}
                 <p className="text-sm text-muted-foreground">{t("setup_permissions_text")}</p>
              </div>
            </CardContent>
          </Card>
           {/* Шаг 3 */}
          <Card className="bg-card border-border shadow-sm">
             <CardHeader><CardTitle className="flex items-center gap-3">
               <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-semibold">3</div>
                 <span className="text-lg">{t("step3_title")}</span>
            </CardTitle></CardHeader>
            <CardContent>
              <p className="mb-4 text-muted-foreground">{t("step3_text")}</p>
              <div className="mt-4 p-3 bg-muted/50 rounded-lg border inline-block">
                 <code className="font-mono text-sm">/story_settings</code>
              </div>
               <p className="text-xs text-muted-foreground mt-2 italic">{t('settings_admin_only', language === 'ru' ? '(Команда доступна только администраторам чата)' : '(Command available only to chat administrators)')}</p> {/* Уменьшил и сделал курсивом */}
            </CardContent>
          </Card>
           {/* Шаг 4 */}
          <Card className="bg-card border-border shadow-sm">
             <CardHeader><CardTitle className="flex items-center gap-3">
               <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary text-primary-foreground font-semibold">4</div>
                 <span className="text-lg">{t("step4_title")}</span>
            </CardTitle></CardHeader>
            <CardContent>
               <p className="text-muted-foreground">{t("step4_text")}</p>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}

--- END OF FILE: src/app/setup/page.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/_components/LanguageProvider.tsx ---

"use client"; 

import React, {
  useState,
  useEffect,
  createContext,
  useContext,
  ReactNode,
  Dispatch,
  SetStateAction,
} from "react";
import { useQuery } from "@tanstack/react-query";
import { apiClient, ApiData, ContentItem, Feature, Example } from "~/client/api"; // Убедитесь, что типы экспортируются из клиента API
import {
  BookOpen,
  UserCircle,
  Image,
  BarChart,
  Settings,
  LucideProps,
} from "lucide-react"; // Импортируем иконки и базовый тип

// --- Типы данных ---
// Можно вынести в отдельный файл src/types.ts

export type Language = "ru" | "en";

// Типы ContentItem, Feature, Example импортируются из клиента API

// --- Карта иконок ---
// Экспортируем, чтобы можно было использовать на страницах
export const iconMap: Record<string, React.ReactElement<LucideProps>> = {
  BookOpen: <BookOpen className="h-6 w-6" />,
  UserCircle: <UserCircle className="h-6 w-6" />,
  Image: <Image className="h-6 w-6" />,
  BarChart: <BarChart className="h-6 w-6" />,
  Settings: <Settings className="h-6 w-6" />,
  // Добавьте другие иконки, если они используются в ваших данных Feature
  Default: <BookOpen className="h-6 w-6" />, // Иконка по умолчанию
};

// --- Тип для значения Контекста ---
interface LanguageContextType {
  language: Language;
  setLanguage: Dispatch<SetStateAction<Language>>;
  t: (key: string, fallback?: string) => string; // Добавим опциональный fallback
  content: ContentItem[];
  features: Feature[];
  examples: Example[];
  isLoadingContent: boolean; // Добавим флаг загрузки
  contentError: unknown; // Добавим информацию об ошибке
}

// --- Создание Контекста с начальными значениями ---
const LanguageContext = createContext<LanguageContextType>({
  language: "en", // Начальное значение по умолчанию
  setLanguage: () => {
    console.warn("setLanguage called outside of LanguageProvider");
  },
  t: (key, fallback) => fallback ?? `[${key}]`, // По умолчанию возвращает ключ или fallback
  content: [],
  features: [],
  examples: [],
  isLoadingContent: true, // Начинаем в состоянии загрузки
  contentError: null,
});

// --- Компонент Провайдера ---
export function LanguageProvider({ children }: { children: ReactNode }) {
  const [language, setLanguage] = useState<Language>("en"); // Начнем с 'en', useEffect обновит

  // Загрузка языка из localStorage или по браузеру при монтировании
  useEffect(() => {
    let initialLang: Language = "en"; // Значение по умолчанию
    const savedLanguage = localStorage.getItem("preferredLanguage");
    if (savedLanguage === "ru" || savedLanguage === "en") {
      initialLang = savedLanguage;
    } else {
      // Проверяем navigator только на клиенте
      if (typeof window !== "undefined") {
        const browserLang = navigator.language.toLowerCase();
        initialLang = browserLang.startsWith("ru") ? "ru" : "en";
      }
    }
    setLanguage(initialLang);
  }, []); // Пустой массив зависимостей - выполнится один раз

  // Сохранение языка в localStorage при изменении
  useEffect(() => {
    // Сохраняем только если язык уже был установлен (избегаем сохранения дефолтного 'en' до гидратации)
     if (language) {
      localStorage.setItem("preferredLanguage", language);
     }
  }, [language]);

  // Запрос данных контента с помощью React Query
  const {
    data,
    isLoading: isLoadingContent,
    error: contentError,
  } = useQuery<ApiData>({
    queryKey: ["websiteContent"],
    queryFn: apiClient.getContent,
    // Опции React Query v5:
    staleTime: 1000 * 60 * 60,           // Считать данные свежими 1 час
    gcTime: 1000 * 60 * 60 * 24,        // ЗАМЕНА: Время хранения в кеше (ранее cacheTime) 24 часа
    refetchOnWindowFocus: false,        // Не перезапрашивать при фокусе окна
    retry: 1,                           // Попробовать перезапросить 1 раз при ошибке
  }); 

  // Подготовка данных (или пустые массивы, если данных нет)
  const content = data?.content || [];
  const features = data?.features || [];
  const examples = data?.examples || [];

  // Функция перевода
  const t = (key: string, fallback?: string): string => {
    // Не ищем перевод, пока контент загружается
    if (isLoadingContent) return fallback ?? "..."; // Показываем троеточие или fallback во время загрузки

    const item = content.find((c) => c.key === key);
    if (!item) {
      console.warn(`Translation key not found: "${key}"`);
      return fallback ?? `[${key}]`; // Возвращаем fallback или ключ для отладки
    }
    // Проверяем наличие нужного языка перед возвратом
    if (language === "ru" && item.valueRu !== undefined && item.valueRu !== null) {
       return item.valueRu;
    }
     if (language === "en" && item.valueEn !== undefined && item.valueEn !== null) {
        return item.valueEn;
     }
     // Если для текущего языка значение пустое, пытаемся вернуть fallback или ключ
     console.warn(`Translation value missing for key: "${key}" in language: "${language}"`);
     return fallback ?? `[${key}]`;
  };

  // --- Обертка для QueryClientProvider ---
  // Обычно QueryClient создается выше и передается сюда,
  // но для простоты примера предположим, что он уже есть в RootLayout
  // Если нет, нужно создать queryClient и обернуть <LanguageContext.Provider> в <QueryClientProvider client={queryClient}>

  return (
    <LanguageContext.Provider
      value={{
        language,
        setLanguage,
        t,
        content,
        features,
        examples,
        isLoadingContent,
        contentError,
      }}
    >
      {children}
    </LanguageContext.Provider>
  );
}

// --- Пользовательский Хук для использования Контекста ---
export function useLanguage() {
  const context = useContext(LanguageContext);
  if (context === undefined) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
}

--- END OF FILE: src/app/_components/LanguageProvider.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/app/_components/SiteLayout.tsx ---

// src/app/_components/SiteLayout.tsx
"use client";

import React, { useState, useEffect, ReactNode } from "react";
import Link from "next/link"; // Используем Link из Next.js для навигации
import { usePathname } from "next/navigation"; // Хук для получения текущего пути
import { useLanguage } from "./LanguageProvider"; // Наш хук для доступа к языку и переводам
import { Button } from "~/components/ui/button"; // Импортируем UI компоненты (shadcn/ui)
import { Menu, X, Globe } from "lucide-react"; // Иконки

// Определяем тип для пропсов компонента
interface SiteLayoutProps {
  children: ReactNode; // Дочерние элементы, которые будут обернуты макетом (наши страницы)
}

export default function SiteLayout({ children }: SiteLayoutProps) {
  // Получаем необходимые данные и функции из контекста языка
  const { language, setLanguage, t } = useLanguage();
  // Состояние для открытия/закрытия мобильного меню
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  // Получаем текущий путь страницы
  const pathname = usePathname();

  // Эффект для автоматического закрытия мобильного меню при смене страницы
  useEffect(() => {
    setIsMenuOpen(false);
  }, [pathname]); // Зависимость от pathname

  // Функция для переключения языка
  const toggleLanguage = () => {
    setLanguage((prevLang) => (prevLang === "ru" ? "en" : "ru"));
  };

  // Получаем имя пользователя бота для ссылки "Добавить в Telegram"
  const botUsername = t("telegram_bot_username", "LetopisetsChatBot");
  const telegramLink = `https://t.me/${botUsername}?startgroup=true`;

  // Массив навигационных ссылок для удобства рендеринга
  const navLinks = [
    { href: "/", labelKey: "hero_title", split: true },
    { href: "/features", labelKey: "features_title" },
    { href: "/setup", labelKey: "setup_title" },
    { href: "/privacy", labelKey: "privacy_policy_title" },
    { href: "/faq", labelKey: "faq_page_title",
      labelRu: "Поддержка / FAQ", labelEn: "Support / FAQ"
     },
  ];

  // Хелпер функция для получения текста ссылки
  const getNavLinkLabel = (link: typeof navLinks[0]): string => {
      if (link.labelRu && language === 'ru') return link.labelRu;
      if (link.labelEn && language === 'en') return link.labelEn;
      const translated = t(link.labelKey);
      return link.split ? translated.split(":")[0] : translated;
  };

  return (
    <div className="min-h-screen flex flex-col">
      {/* Шапка сайта */}
      <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="container mx-auto px-4 h-16 flex items-center justify-between">
          {/* Логотип/Название сайта */}
           <Link href="/" className="text-xl font-bold mr-4 flex-shrink-0">
             {t('site_name', language === "ru" ? "Летописец Чата" : "Chat Chronicler")}
          </Link>

          {/* Навигация для десктопа */}
          <nav className="hidden md:flex flex-grow items-center gap-1 lg:gap-2 justify-end"> {/* Уменьшены gap */}
            {navLinks.map((link) => (
              <Link key={link.href} href={link.href} passHref> {/* Убран legacyBehavior */}
                <Button
                  variant={pathname === link.href ? "secondary" : "ghost"}
                  size="sm" // Уменьшен размер кнопок навигации
                  asChild
                >
                  {/* Тег <a> НЕ НУЖЕН */}
                  <span>{getNavLinkLabel(link)}</span>
                </Button>
              </Link>
            ))}
             {/* Кнопка смены языка */}
            <Button
              variant="ghost"
              size="icon"
              onClick={toggleLanguage}
              aria-label={t('toggle_language_aria', 'Toggle language')}
            >
              <Globe className="h-5 w-5" />
            </Button>
             {/* Кнопка "Добавить в Telegram" */}
            <Button asChild size="sm">
               {/* Убран тег <a> */}
              <a href={telegramLink} target="_blank" rel="noopener noreferrer">
                {t("cta_button", "Add to Telegram")}
              </a>
            </Button>
          </nav>

           {/* Кнопки для мобильного меню */}
          <div className="flex items-center gap-2 md:hidden">
            <Button
              variant="ghost"
              size="icon"
              onClick={toggleLanguage}
              aria-label={t('toggle_language_aria', 'Toggle language')}
            >
              <Globe className="h-5 w-5" />
            </Button>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              aria-label={t('toggle_menu_aria', 'Toggle menu')}
            >
              {isMenuOpen ? <X className="h-5 w-5" /> : <Menu className="h-5 w-5" />}
            </Button>
          </div>
        </div>

        {/* Выпадающее мобильное меню */}
        {isMenuOpen && (
          <div className="md:hidden border-t bg-background shadow-md">
            <div className="container mx-auto px-4 py-4">
              <nav className="flex flex-col gap-3">
                {navLinks.map((link) => (
                  <Link key={link.href} href={link.href} passHref> {/* Убран legacyBehavior */}
                     <Button
                        variant={pathname === link.href ? "secondary" : "ghost"}
                        className="w-full justify-start text-base"
                        asChild
                     >
                        {/* Тег <a> НЕ НУЖЕН */}
                       <span>{getNavLinkLabel(link)}</span>
                    </Button>
                  </Link>
                ))}
                <Button asChild className="mt-4 text-base">
                   {/* Убран тег <a> */}
                  <a href={telegramLink} target="_blank" rel="noopener noreferrer">
                    {t("cta_button", "Add to Telegram")}
                  </a>
                </Button>
              </nav>
            </div>
          </div>
        )}
      </header>

      {/* Основной контент страницы (передается через children) */}
      <main className="flex-grow">
        {children}
      </main>

      {/* Подвал сайта */}
      <footer className="bg-muted py-6 mt-auto">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <div className="text-sm text-muted-foreground">
              {t("footer_copyright", `© ${new Date().getFullYear()} Chat Chronicler`)}
            </div>
            <div className="flex flex-wrap justify-center gap-x-4 gap-y-2"> {/* Добавлен flex-wrap */}
               {/* Убран legacyBehavior и тег <a> */}
              <Link href="/privacy" className="text-sm text-muted-foreground hover:text-foreground">
                  {t("privacy_policy_title", "Privacy Policy")}
              </Link>
              <Link href="/faq" className="text-sm text-muted-foreground hover:text-foreground">
                   {t('faq_link_footer', language === "ru" ? "Поддержка / FAQ" : "Support / FAQ")}
              </Link>
               {/* Ссылка на канал поддержки */}
               {t('support_channel_link', '#') !== '#' && t('support_channel_link') !== '[support_channel_link]' && ( // Улучшенная проверка
                 <a href={t('support_channel_link')} target="_blank" rel="noopener noreferrer" className="text-sm text-muted-foreground hover:text-foreground">
                   {t('support_channel_text', 'Support Channel')}
                 </a>
               )}
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
}

--- END OF FILE: src/app/_components/SiteLayout.tsx ---

-------------------------------------------------------------------------------

--- START OF FILE: src/client/api.ts ---

// src/client/api.ts

// Типы данных, соответствующие ожидаемым от API
export type ContentItem = { id: string; key: string; valueRu: string; valueEn: string; };
export type Feature = { id: string; titleRu: string; titleEn: string; descriptionRu: string; descriptionEn: string; icon: string; order: number; };
export type Example = { id: string; personalityRu: string; personalityEn: string; contentRu: string; contentEn: string; order: number; };

export interface ApiData {
  content: ContentItem[];
  features: Feature[];
  examples: Example[];
}

// Функция для получения данных с нашего же API
async function getContent(): Promise<ApiData> {
  const response = await fetch('/api/content'); // Относительный путь к API Route
  if (!response.ok) {
    throw new Error(`Failed to fetch API data: ${response.statusText}`);
  }
  return await response.json();
}

// Экспортируем клиент
export const apiClient = {
  getContent,
};

// Тестовый код из вашего api.ts можно оставить здесь или перенести в отдельный тестовый файл
// Но его НЕ НУЖНО экспортировать в apiClient
// async function _runApiTests() { ... }

--- END OF FILE: src/client/api.ts ---

-------------------------------------------------------------------------------

===============================================================================
 КОНЕЦ БАНДЛА
===============================================================================
